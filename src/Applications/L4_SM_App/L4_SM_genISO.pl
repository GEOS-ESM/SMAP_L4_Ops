#!/usr/bin/perl

#******************************************************************************
# English Name: Level-4 Soil Moisture - Generate ISO
# -------------
#
# The text following this prolog contains documentation for this application
# using Perl POD markup language. Formatted documentation can be obtained
# using the following commands:
#
#        perldoc L4_SM_genISO.pl
#        L4_SM_genISO.pl -h|-help
#        L4_SM_genISO.pl -man
#
#******************************************************************************

=head1 NAME

L4_SM_genISO.pl - Creates Level-4 Soil Moisture (L4_SM) granules in HDF-5 format with ISO metadata.

=head1 SYNOPSIS

L4_SM_genISO.pl [-h|help] [-man] [-sn|stream_name name] [-st|stream_type type] [-date date] [-pc counter]

=head1 OPTIONS

=over 17

=item -h|help

Print a brief help message and exit.

=item -man

Print this command's manual page and exit.

=item -sn|stream_name name

Set the stream name, which is also the name of the last directory in the
fully qualified path location of the stream.

=item -st|stream_type type

Set the stream type, which is also the last parent directory in the fully
qualified path location of the stream.

=item -date date

Set the data day to process specified as ccyymmdd.

=item -pc counter

Set the product counter. I<counter> is an integer between 1 and 999. The default
value is 1. The HDF-5 granules include the 3-digit product counter in the
filename. Specify the next value in sequence when the HDF-5 granules are to be
re-generated without overwriting granules from prior invocation of this
application.

=back

=head1 DESCRIPTION

Generates SMAP Level-4 Soil Moisture (L4_SM) granules for the data collections
defined in the L4_SM product specification document (PSD). HDF-5 files with a
full complement of ISO 19115 metadata as HDF groups and ISO 19139 XML are
created.

=head1 NOTES

=over 4

=item 1.

This application requires a configured L4_SM data stream. The following
documentation is available:

 "SMAP Level-4 SPS User Guide"
 "SMAP Level-4 Soil Moisture SPS User Guide"

=item 2.

This application operates on data sets generated by the model application
component of the L4_SM SPS - L4_SM.pl. Please reference the L4_SM.pl
application for additional information.

=item 3.

This application is typically invoked by L4_SM.pl. It can also operate as a
standalone application.

=item 4.

The L4 SPS keeps a record of completed tasks. This application will simply exit
if the system records indicate that processing was completed for the specified
date. Use the L4 SPS dashboard command (L4.pl) to delete old files. For example:

L4.pl -remove history -st SPL4SM -sn V06006 -task genISO -date 20140101

Please reference the L4 SPS documentation for more information.

=back

=head1 SEE ALSO

L4_SM.pl(1), L4.pl(1)

=head1 AUTHORS

Joseph V. Ardizzone - NASA Goddard Space Flight Center, Global Modeling and Assimilation Office (GMAO)

=head1 COPYRIGHT

This software is the property of the National Aeronautics and Space
Administration (NASA) and is subject to the regulations contained in the NASA
Procedural Requirements document NPR 2210.1C managed by the Office of the Chief
Technologist.

=cut

#******************************************************************************
# English Name: Level-4 Soil Moisture SPS - Generate ISO
# -------------
#
# Purpose: Generates SMAP Level-4 Soil Moisture (L4_SM) granules for the data
# -------- collections defined in the L4_SM product specification document
#          (PSD). HDF-5 files with a full complement of ISO 19115 metadata as
#          HDF groups and ISO 19139 XML are created.
#
# Language: Perl
# ---------
#
# Notes: 1. This application requires a configured L4_SM data stream. The
# ------    following documentation is available:
#
#           "SMAP Level-4 SPS User Guide"
#           "SMAP Level-4 Soil Moisture SPS User Guide"
#
#        2. This application operates on data sets generated by the model
#           application component of the L4_SM SPS - L4_SM.pl. Please reference
#           the L4_SM.pl application for additional information.
#
#        3. This application is typically invoked by L4_SM.pl. It can also
#           operate as a standalone application. 
#
#        4. The L4 SPS keeps a record of completed tasks. This application will
#           simply exit if the system records indicate that processing was
#           completed for the specified date/time. Use the L4 SPS dashboard
#           command (L4.pl) to delete old files. Please reference the L4 SPS
#           documentation for more information. 
#
# See Also: L4_SM.pl, DMGR.pm, CONFIG.pm, DTR.pm, CLOCK.pm, FIND.pm,
# --------  METADATA.pm, ERROR::Handler.pm, LOG::Handler.pm
#
# Prerequisite: L4_SM.pl
# -------------
#
# Usage: L4_SM_genISO.pl [path] [ccyymmdd] [hhmmss] [-pc product counter]
# ------
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# path                  string       IN  Absolute path of the target L4_SM data
#                                        stream. For example:
#
#                                        /home/Operations/SPL4SM/SPL4SM_V05002
#
# ccyymmdd             integer       IN  Date to be processed (e.g. 20140101).
#
# hhmmss               integer       IN  Time to be processed. This application
#                                        operates in 1-day segements. This 
#                                        argument is currently not used.
#
# product counter      integer   OPT,IN  Optional product counter (default: 1)
#
# L4_SM_genISO.pl      integer      OUT  function return value:
#
#                                        0: success
#
#                                        1: usage error or runtime configuration
#                                           error.
#
#                                        2: Error occurred while generating the
#                                           L4_C granules.
#
#                                        3: Granule verification failed.
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           09/16/2014      J.Ardizzone  documented.
#******************************************************************************

  use strict;

  use File::Path;
  use File::Copy;
  use File::Basename;
  use File::Spec;
  use Getopt::Std;
  use Getopt::Long;
  use Pod::Usage;
  use Data::UUID;
  use List::Util qw(min max);

  use CLOCK;
  use Time::Piece;
  use Time::Local;
  use Time::Seconds;

  use CONFIG;
  use FIND;
  use DTR;
  use DMGR;
  use FIND;
  use LOG::Handler;
  use METADATA;
  use L4_SM::LOG;
  use L4_SM::OBSLOG;
  use L4_SM::AUP::QA;
  use L4_SM::GPH::QA;
  use L4_SM::LMC::QA;
  use ERROR::Handler;

# Retrieve run-time input
# parameters
# =======================

  my $config = getRunTimeConfig();

  ERROR_HANDLE:  my $this = "L4_SM_genISO";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  $eh->comment("Begin Generation of SMAP Granules");

# Configure the job
# =================

  $config->jobConfig($config->{L4_SM_RIP},$config->{L4_SM_RUN},TIMELESS=>1);

# Retrieve the LDAS tile
# coordinate file.
# ======================

  getTileCoordFile($config);
  exit 3 if $eh->isError();

# Locate the input/output
# transactions.
# =======================

  my $input  = DMGR->new($config->{L4_SM_INPUT},%$config);
  my $output = DMGR->new($config->{L4_SM_OUTPUT},%$config);

# Generate the LDAS data collections
# for DAAC distribution.
# ==================================

  genDAAC($input,$output,$config);
  exit 4 if $eh->isError();

  $output->execute("AUP");
  $output->execute("GPH");
  $output->execute("LMC");

  $eh->comment("End Generation of SMAP Granules");

exit 0;

#******************************************************************************
sub genDAAC { DMGR:   my $input = shift;
              DMGR:   my $output = shift;
              CONFIG: my $config = shift;
#******************************************************************************
# English Name: Generate Data for Distributed Active Archive Centers (DAAC)
# -------------
#
# Purpose: Generates Land Data Assimilation System (LDAS) data for the 
# -------- data collections defined in the L4_SM SMAP product specification
#          document (PSD). HDF-5 files with a full complement of ISO 19115
#          metadata as HDF groups and ISO 19139 XML will be created using the
#          input and output specifications.
#
# Language: Perl
# ---------
#
# Notes: 1. This method assumes that the temporal spacing between granules
# ------    is a multiple of a 30 minute interval.
#
# See Also: DMGR.pm, CONFIG.pm, DTR.pm
# ---------
#
# Usage: $rc = genDAAC($input,$output,$config);
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing all runtime
#                                        configuration parameters.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Data transaction file is missing
#                                           for a collection type.
#                                        2: Error returned from called method.
#
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           06/09/2014      J.Ardizzone  documented.
#******************************************************************************

  FUNCTION_NAME: my $this = "genDAAC";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  $eh->comment( "Generating DAAC granules");

# Set earliest and latest granule times.
# ======================================

  DTR: my $dtr;
  CLOCK: my (@tstart, @tend);

  $dtr = $input->{"GPH"}; $dtr or return $eh->fatal(1,TYPE=>"GPH");
  ($tstart[0], $tend[0]) = $dtr->times();

  $dtr = $input->{"AUP"}; $dtr or return $eh->fatal(1,TYPE=>"AUP");
  ($tstart[1], $tend[1]) = $dtr->times();

  $dtr = $input->{"LMC"}; $dtr or return $eh->fatal(1,TYPE=>"LMC");
  ($tstart[2], $tend[2]) = $dtr->times();

  my $tstart = pop @tstart;
  my $tend   = pop @tend;

  foreach my $t (@tstart) { $tstart = $t if $t < $tstart }
  foreach my $t (@tend) { $tend = $t if $t > $tend }

# Generate the granules for the collection
# types defined in the L4_SM PSD. Search for
# files in 30 minute intervals. This allows
# some flexibility for changing requirements.
# ===========================================

  for (my $t = $tstart; $t <= $tend; $t+=1800) {

    genLMC($t,$input,$output,$config);
    $eh->isError() and return $eh->traceback(2);

    genGPH($t,$input,$output,$config);
    $eh->isError() and return $eh->traceback(2);

    genAUP($t,$input,$output,$config);
    $eh->isError() and return $eh->traceback(2);

  }

return 1;

}

#******************************************************************************
sub genGPH { CLOCK:  my $time = shift;
             DMGR:   my $input = shift;
             DMGR:   my $output = shift;
             CONFIG: my $config = shift;
#******************************************************************************
# English Name: Generate GPH Granule
# -------------
#
# Purpose: Generates a Geophysical (GPH) granule for the specified
# -------- date/time if the input data exists. GPH is one of the collection
#          types produced by the Land Data Assimilation System (LDAS).
#
# Language: Perl
# ---------
#
# Usage: $rc = genGPH($time,$input,$output,$config);
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the granule
#                                        date/time.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing all runtime
#                                        configuration parameters.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Data transaction file is missing
#                                           for input GPH data.
#
#                                        2: Data transaction file is missing
#                                           for output GPH data.
#
#                                        3: Error returned from called method.
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           03/22/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "genGPH";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Return if there is no GPH input
# data for the specified time.
# ===============================

  $input->{GPH} or return $eh->fatal(1,TYPE=>"GPH");
  $output->{GPH} or return $eh->fatal(2,TYPE=>"GPH");

  DTR: my $dtr = $input->{GPH};

  METADATA:  my $metadata = $config->clone(COLLECTION_ID=>"GPH");
  FILENAMES: my @files = $dtr->files();
  FILETMPLT: my ($file)  = grep /\.bin/, @files;
  FILENAME:  my $pathname = $config->time_interp($file,$time);

  -f $pathname or return 0;

  ($output->stat("GPH",CLOCK=>$time))[0] and return 1;

  my $datetime = $time->datetime;
  $eh->comment( "Generating GPH granules for $datetime");

# Create the GPH granule
# ======================

  getLFOInfo($time,$input,$metadata);
  $eh->isError() and return $eh->traceback(3);

  getCRIDInfo($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  $file = (findLastFile($time,$output->{AUP},$config))[1];
  getSMAPDocInfo($file, $metadata);

  genHDF($time, $input, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  genQA($time, $input, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  getGPHInfo($time,$input,$metadata);
  $eh->isError() and return $eh->traceback(3);

  insertGroupMeta($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertConfig($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  compressHDF($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertXMLMeta($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertSeriesXML($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  return 1;
}

#******************************************************************************
sub genAUP { CLOCK:  my $time = shift;
             DMGR:   my $input = shift;
             DMGR:   my $output = shift;
             CONFIG: my $config = shift;
#******************************************************************************
# English Name: Generate AUP Granule
# -------------
#
# Purpose: Generates an Analysis Update (AUP) graule for the specified
# -------- date/time if the input data exists. AUP is one of the collection
#          types produced by the Land Data Assimilation System (LDAS).
#
# Language: Perl
# ---------
#
# Usage: $rc = genAUP($time,$input,$output,$config);
# ------ $exception = if $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the granule
#                                        date/time.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing all runtime
#                                        configuration parameters.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Data transaction file is missing
#                                           for input AUP data.
#
#                                        2: Data transaction file is missing
#                                           for output AUP data.
#
#                                        3: Error returned from called method.
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           03/22/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "genAUP";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Return if there is no AUP input
# data for the specified time.
# ===============================

  $input->{AUP} or return $eh->fatal(1,TYPE=>"AUP");
  $output->{AUP} or return $eh->fatal(2,TYPE=>"AUP");

  DTR: my $dtr = $input->{AUP};

  METADATA:  my $metadata = $config->clone(COLLECTION_ID=>"AUP");
  FILETMPLT: my @files = $dtr->files();
  FILETMPLT: my ($file)  = grep /\.bin/, @files;
  FILENAME:  my $pathname = $config->time_interp($file,$time);

  -f $pathname or return 0;

  ($output->stat("AUP",CLOCK=>$time))[0] and return 1;

  my $datetime = $time->datetime;
  $eh->comment( "Generating AUP granules for $datetime");

# Create the AUP granule
# ======================

  getOBSInfo($time,$input,$metadata);
  $eh->isError() and return $eh->traceback(3);

  getCRIDInfo($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  genHDF($time, $input, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  genQA($time, $input, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  getAUPInfo($time,$input,$metadata);
  $eh->isError() and return $eh->traceback(3);

  insertGroupMeta($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertConfig($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  compressHDF($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertXMLMeta($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertSeriesXML($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  return 1;
}

#******************************************************************************
sub genLMC { CLOCK:  my $time = shift;
             DMGR:   my $input = shift;
             DMGR:   my $output = shift;
             CONFIG: my $config = shift;
#******************************************************************************
# English Name: Generate LMC Granule
# -------------
#
# Purpose: Generates a Land-Model-Constants granule for the specified
# -------- date/time if the input data exists. LMC is one of the collection
#          types produced by the Land Data Assimilation System (LDAS).
#
# Language: Perl
# ---------
#
# Usage: $rc = genLMC($time,$input,$output,$config);
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the granule
#                                        date/time.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing all runtime
#                                        configuration parameters.
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Data transaction file is missing
#                                           for input LMC data.
#
#                                        2: Data transaction file is missing
#                                           for output LMC data.
#
#                                        3: Error returned from called method.
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           03/22/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "genLMC";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Return if there is no LMC input
# data for the specified time.
# ===============================

  $input->{LMC} or return $eh->fatal(1,TYPE=>"LMC");
  $output->{LMC} or return $eh->fatal(2,TYPE=>"LMC");

  DTR: my $dtr = $input->{LMC};

  METADATA:  my $metadata = $config->clone(COLLECTION_ID=>"LMC");
  FILENAMES: my @files = $dtr->files();
  FILETMPLT: my ($file)  = grep /\.bin/, @files;
  FILENAME:  my $pathname = $config->time_interp($file,$time);

  -f $pathname or return 0;

  ($output->stat("LMC"))[0] and return 1;

  my $datetime = $time->datetime;
  $eh->comment( "Generating LMC granules for $datetime");

# Create the LMC granule
# ======================

  getCRIDInfo($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  genHDF($time, $input, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  genQA($time, $input, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  getLMCInfo($time,$input,$metadata);
  $eh->isError() and return $eh->traceback(3);

  insertGroupMeta($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertConfig($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  compressHDF($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertXMLMeta($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  insertSeriesXML($time, $output, $metadata);
  $eh->isError() and return $eh->traceback(3);

  return 1;
}

#******************************************************************************
sub getLFOInfo { CLOCK:    my $time   = shift;
                 DMGR:     my $input  = shift;
                 CONFIG:   my $config = shift;
#******************************************************************************
# English Name: Get LFO Information
# -------------
#
# Purpose: Extracts pertinent metadata information from the Land Data
# -------- Assimilation System (LDAS) output log file; specifically, land
#          forcing files affecting the analysis at the specified date/time.
#
# Language: Perl
# ---------
#
# Usage: $rc = getLFOInfo($time,$input,$config);
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the date/time
#                                        of the desired information.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $config               CONFIG    INOUT  CONFIG referent to receive the
#                                        metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: LDAS LOG transaction is missing
#                                        2: LDAS LOG file is missing
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/23/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "getLFOInfo";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  my $datetime = $time->datetime;
  $eh->comment("Retrieving LFO information for $datetime");

# Return if the log file is missing.
# ==================================

  $input->{RC_OUT} or return $eh->fatal(1,TYPE=>"RC_OUT");

  FILENAMES: my @files = $input->files("RC_OUT");
  FILENAME:  my ($log_name) = grep /ldas_log/, @files;

  -f $log_name or return $eh->error(2,FILE=>$log_name);

# Read and extract data from the
# LOG file.
# ==============================

  LOG:       my $lfo   = L4_SM::LOG->lfo($log_name);
  HASH_REF:  my $hash1 = $lfo->{LFO_fileName};
  HASH_REF:  my $hash2 = $lfo->{LFO_creationDate};
  HASH_REF:  my $hash3 = $lfo->{LFO_version};
  HASH_REF:  my $hash4 = $lfo->{LFO_DOI};

# Collect all land-forcing files within
# a 3-hour window centered on the
# specified time: [t-5400,t,t+5400].
# ======================================

  CLOCK:  my $tstart = $time - 5400;
  CLOCK:  my $tend = $time + 5400;

  STRING: my ($doi, $doi_corr);
  STRING: my ($version, $version_corr);
  STRING: my ($fileName, $fileName_corr);
  STRING: my ($lastFile, $lastFile_corr);
  STRING: my ($creationDate, $creationDate_corr);

  for (my $t = $tstart; $t <= $tend; $t+=1800) {

    my $index = -1;
    my $datetime = $t->strftime("%Y%m%d%H%M");

    my $array1 = $hash1->{$datetime} // [];
    my $array2 = $hash2->{$datetime} // [];
    my $array3 = $hash3->{$datetime} // [];
    my $array4 = $hash4->{$datetime} // [];

    my $files = basenames($array1);

    foreach (@$array1) {

      $index++;

      $files->[$index] =~ /_corr/ and do {

        $lastFile_corr     = $array1->[$index];

        $fileName_corr     = append([$fileName_corr,$files->[$index]]);
        $creationDate_corr = append([$creationDate_corr,$array2->[$index]]);
        $version_corr      = append([$version_corr,$array3->[$index]]);
        $doi_corr          = append([$doi_corr,$array4->[$index]]);
        next;

      };

      $lastFile     = $array1->[$index] if $array1->[$index] =~ /inst1_2d/;

      $fileName     = append([$fileName,$files->[$index]]);
      $creationDate = append([$creationDate,$array2->[$index]]);
      $version      = append([$version,$array3->[$index]]);
      $doi          = append([$doi,$array4->[$index]]);

    }

  }

  GEOS5_LFO_NAMESPACE:

  $config->{GEOS5_lfo_FILE}         = $lastFile;
  $config->{GEOS5_lfo_fileName}     = $fileName;
  $config->{GEOS5_lfo_creationDate} = $creationDate;
  $config->{GEOS5_lfo_version}      = $version;
  $config->{GEOS5_lfo_DOI}          = $doi;

  GEOS5_LFO_CORR_NAMESPACE:

  $config->{GEOS5_lfo_corr_FILE}         = $lastFile_corr;
  $config->{GEOS5_lfo_corr_fileName}     = $fileName_corr;
  $config->{GEOS5_lfo_corr_creationDate} = $creationDate_corr;
  $config->{GEOS5_lfo_corr_version}      = $version_corr;
  $config->{GEOS5_lfo_corr_DOI}          = $doi_corr;

  $config->{LOG_creationDate} = $lfo->{LOG_creationDate};

  return 1;
}

#******************************************************************************
sub getGPHInfo { CLOCK:  my $time = shift;
                 DMGR:   my $input = shift;
                 CONFIG: my $config = shift;
#******************************************************************************
# English Name: Get GPH Information
# -------------
#
# Purpose: Generates metadata for the Land Data Assimilation System (LDAS)
# -------- Geophysical (GPH) data collection for the specified date/time.
#
#
# Language: Perl
# ---------
#
# Notes: 1. This method reads information from the GPH Quality Assurance (QA)
# ------    file for the specified date/time.
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, DTR.pm, DTR::*.pm, L4_SM::GPH::QA.pm
# --------- genQA()
#
# Usage: $rc = getGPHInfo($time,$input,$config);
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the date/time
#                                        of the desired information.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $config               CONFIG    INOUT  CONFIG class hash referent to receive
#                                        the metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#                                        The time format (where applicable) is
#                                        in the following form:
#
#                                        e.g. 2000-02-29T12:34:56
#
#  {QA_FILE}                         IN  pathname of QA file (see genQA())
#
#  {SPL4SM_stepDateTime}            OUT  date/time of processing.
#
#  {SPL4SM_rangeBeginningDateTime}  OUT  start time of data period.
#
#  {SPL4SM_rangeEndingDateTime}     OUT  end time of data period.
#
#  {SPL4SM_creationDate}            OUT  date/time of processing.
#
#                                        see also: L4_SM::GPH::QA::addMeta()
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: LDAS GPH transaction is missing
#                                        2: LDAS GPH QA file is missing
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/23/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "getGPHInfo";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  my $datetime = $time->datetime;
  $eh->comment("Retrieving GPH information for $datetime");

# Return if the GPH transaction is missing
# ========================================

  DTR: my $dtr = $input->{GPH};
  $dtr or return $eh->fatal(1,TYPE=>"GPH");
  
# Add time information
# ====================

  CLOCK: my $tstep  = CLOCK->new();
  CLOCK: my $tstart = $time - 5400;
  CLOCK: my $tend   = $time + 5400;

  $config->{SPL4SM_stepDateTime} = $tstep->datetime . ".000Z";
  $config->{SPL4SM_rangeBeginningDateTime} = $tstart->datetime . ".000Z";
  $config->{SPL4SM_rangeEndingDateTime} = $tend->datetime . ".000Z";
  $config->{SPL4SM_creationDate} = $tstep->datetime . ".000Z";

# Add QA Information
# ==================

  my $qa_file = $config->{QA_FILE};
  -f $qa_file or return $eh->error(2,FILE=>$qa_file);
  QA: my $qa = L4_SM::GPH::QA->new($qa_file);

  $qa->addMeta($config);

  return 1;
}

#******************************************************************************
sub getAUPInfo { CLOCK:  my $time = shift;
                 DMGR:   my $input = shift;
                 CONFIG: my $config = shift;
#******************************************************************************
# English Name: Get AUP Information
# -------------
#
# Purpose: Generates metadata for the Land Data Assimilation System (LDAS)
# -------- Analysis Update (AUP) data collection for the specified date/time.
#
# Language: Perl
# ---------
#
# Notes: 1. This method reads information from the AUP Quality Assurance (QA)
# ------    file for the specified date/time.
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, DTR.pm, DTR::*.pm, L4_SM::AUP::QA.pm
# --------- genQA()
#
# Usage: $rc = getAUPInfo($time,$input,$config);
# ------ $rc = -1 if $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the date/time
#                                        of the desired information.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $config               CONFIG    INOUT  CONFIG class hash referent to receive
#                                        the metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#                                        The time format (where applicable) is
#                                        in the following form:
#
#                                        e.g. 2000-02-29T12:34:56
#
#  {QA_FILE}                         IN  pathname of QA file (see genQA())
#
#  {SPL4SM_stepDateTime}            OUT  date/time of processing.
#
#  {SPL4SM_rangeBeginningDateTime}  OUT  start time of data period.
#
#  {SPL4SM_rangeEndingDateTime}     OUT  end time of data period.
#
#  {SPL4SM_creationDate}            OUT  date/time of processing.
#
#                                        see also: L4_SM::AUP::QA::addMeta()
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh            ERROR::Handler     OUT  ERROR::Handler referent.
#
# $exception            integer     OUT  Thrown Exception:
#
#                                        1: LDAS AUP transaction is missing
#                                        2: LDAS AUP QA file is missing
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/24/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "getAUPInfo";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  my $datetime = $time->datetime;
  $eh->comment("Retrieving AUP information for $datetime");

# Return if the AUP transaction is missing
# ========================================

  DTR: my $dtr = $input->{AUP};
  $dtr or return $eh->fatal(1,TYPE=>"AUP");

# Add time information
# ====================

  CLOCK: my $tstep  = CLOCK->new();
  CLOCK: my $tstart = $time - 5400;
  CLOCK: my $tend   = $time + 5400;

  $config->{SPL4SM_stepDateTime} = $tstep->datetime . ".000Z";
  $config->{SPL4SM_rangeBeginningDateTime} = $tstart->datetime . ".000Z";
  $config->{SPL4SM_rangeEndingDateTime} = $tend->datetime . ".000Z";
  $config->{SPL4SM_creationDate} = $tstep->datetime . ".000Z";

# Add QA Information
# ==================

  my $qa_file = $config->{QA_FILE};
  -f $qa_file or return $eh->error(2,FILE=>$qa_file);
  QA: my $qa = L4_SM::AUP::QA->new($qa_file);

  $qa->addMeta($config);

  return 1;
}

#******************************************************************************
sub getLMCInfo { CLOCK:  my $time = shift;
                 DMGR:   my $input = shift;
                 CONFIG: my $config = shift;
#******************************************************************************
# English Name: Get LMC Information
# -------------
#
# Purpose: Generates metadata for the Land Data Assimilation System (LDAS)
# -------- Land-Model_Constants data collection for the specified date/time.
#
#
# Language: Perl
# ---------
#
# Notes: 1. This method reads information from the LMC Quality Assurance (QA)
# ------    file for the specified date/time.
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, DTR.pm, DTR::*.pm, L4_SM::LMC::QA.pm
# --------- genQA()
#
# Usage: $rc = getLMCInfo($time,$input,$config);
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the date/time
#                                        of the desired information.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $config               CONFIG    INOUT  CONFIG class hash referent to receive
#                                        the metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#                                        The time format (where applicable) is
#                                        in the following form:
#
#                                        e.g. 2000-02-29T12:34:56
#
#  {QA_FILE}                         IN  pathname of QA file (see genQA())
#
#  {SPL4SM_stepDateTime}            OUT  date/time of processing.
#
#  {SPL4SM_rangeBeginningDateTime}  OUT  start time of data period.
#
#  {SPL4SM_rangeEndingDateTime}     OUT  end time of data period.
#
#  {SPL4SM_creationDate}            OUT  date/time of processing.
#
#                                        see also: L4_SM::AUP::QA::addMeta()
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh            ERROR::Handler     OUT  ERROR::Handler referent.
#
# $exception            integer     OUT  Thrown Exception:
#
#                                        1: LDAS LMC transaction is missing
#                                        2: LDAS LMC QA file is missing
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/23/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "getLMCInfo";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  my $datetime = $time->datetime;
  $eh->comment("Retrieving LMC information for $datetime");

# Return if the LMC transaction is missing
# ========================================

  DTR: my $dtr = $input->{LMC};
  $dtr or return $eh->fatal(1,TYPE=>"LMC");
  
# Add time information
# ====================

  CLOCK: my $tstep  = CLOCK->new();
  CLOCK: my $tstart = $time;
  CLOCK: my $tend   = $time + 86400 - 1;

  $config->{SPL4SM_stepDateTime} = $tstep->datetime . ".000Z";
  $config->{SPL4SM_rangeBeginningDateTime} = $tstart->datetime . ".000Z";
  $config->{SPL4SM_rangeEndingDateTime} = $tend->datetime . ".000Z";
  $config->{SPL4SM_creationDate} = $tstep->datetime . ".000Z";

# Add QA Information
# ==================

  my $qa_file = $config->{QA_FILE};
  -f $qa_file or return $eh->error(2,FILE=>$qa_file);
  QA: my $qa = L4_SM::LMC::QA->new($qa_file);

  $qa->addMeta($config);

  return 1;
}

#******************************************************************************
sub getOBSInfo { CLOCK:  my $time = shift;
                 DMGR:   my $input = shift;
                 CONFIG: my $config = shift;
#******************************************************************************
# English Name: Get Observation Information
# -------------
#
# Purpose: Extracts pertinent metadata information from the Land Data
# -------- Assimilation System (LDAS) AUP observation LOG (OBSLOG) file for the
#          the specified date/time.
#
# Language: Perl
# ---------
#
# Usage: $rc = getOBSInfo($time,$input,$config);
# ------ $rc = -1 if $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the date/time
#                                        of the desired information.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $config               CONFIG    INOUT  CONFIG referent to receive the
#                                        metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#
# $rc                  integer      OUT  function return value (see usage):
#
#                                        1: success
#                                       -1: Exception occurred
#
# $eh            ERROR_HANDLER      ---  ERROR::Handler referent.
#
#                                        Thrown Exceptions:
#
#                                        1: LDAS OBSLOG transaction is missing
#                                        2: LDAS OBSLOG file is missing
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/24/2014      J.Ardizzone  created.
#           07/26/2014      J.Ardizzone  make corrections to include the
#                                        ascending orbits in the L1C_TB listing.
#******************************************************************************

  FUNCTION_NAME: my $this = "getOBSInfo";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  my $datetime = $time->datetime;
  $eh->comment("Retrieving observation information for $datetime");

# Return if the OBSLOG file is missing.
# =====================================

  DTR: my $dtr = $input->{RC_OUT};
  $dtr or return $eh->fatal(1,TYPE=>"AUP");

# Retrieve the OBSLOG file information
# ====================================

  CLOCK:     my $tstart = ($dtr->times())[0];
  FILETMPLT: my @files = $dtr->files();
  FILETMPLT: my $file  = (grep /ldas_obslog.*\.txt$/, @files)[0];
  FILENAME:  my $pathname = $config->time_interp($file,$tstart);

  -f $pathname or return $eh->error(2,FILE=>$pathname);

  OBSLOG: my $obslog = L4_SM::OBSLOG->new($pathname,$time);

# Retrieve information on the SMAP
# files used by the LDAS for the
# specified date/time.
# =================================

  HASH_REF:  my $hash;
  ARRAY:     my @files;
  ARRAY_REF: my ($files_A, $files_D);

  SPL1CTB:

  $hash = $obslog->{SMAP_L1C_Tbh_D} // {};
  $files_D = $hash->{FILENAMES} // [];
  $hash = $obslog->{SMAP_L1C_Tbh_A} // {};
  $files_A = $hash->{FILENAMES} // [];

  @files = sort (@$files_D, @$files_A);
  mgetSMAPInfo("SPL1CTB",\@files,$config);

  SPL2SMAP:

  $hash = $obslog->{SMAP_L2AP_Tbh_D} // {};
  $files_D = $hash->{FILENAMES} // [];
  mgetSMAPInfo("SPL2SMAP",$files_D,$config);

  SPL2SMA:

  $hash = $obslog->{SMAP_L2A_Tbh_D} // {};
  my $files_D = $hash->{FILENAMES} // [];
  mgetSMAPInfo("SPL2SMA",$files_D,$config);

  getSMAPDocInfo($config->{SMAP_LAST_FILE},$config);

}

#******************************************************************************
sub mgetSMAPInfo { SMAP_ID:    my $id = shift;
                   SMAP_FILES: my $files = shift;
                   CONFIG:     my $config = shift;
#******************************************************************************
# English Name: Multiple Get SMAP Information
# -------------
#
# Purpose: Extracts pertinent metadata information from the specified SMAP
# -------- files by querying the ISO 19115 metadata group information contained
#          on the files.
#
# Language: Perl
# ---------
#
# Usage: $rc = getSMAPInfo($file,$config);
# ------ $rc = -1 if $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $id                   string       IN  SMAP identifier (short ECS name) 
#                                        describing the SMAP product type for
#                                        the listed files.
#
# $files                string       IN  Array of SMAP files containing ISO
#                                        19115 metadata groups and having the
#                                        specified SMAP ID product type.
#
# $config               CONFIG    INOUT  CONFIG referent to receive the
#                                        metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#
# $rc                  integer      OUT  function return value (see usage):
#
#                                        1: success
#                                       -1: Exception occurred
#
# $eh            ERROR_HANDLER      ---  ERROR::Handler referent.
#
#                                        Thrown Exceptions: none
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/24/2014      J.Ardizzone  created.
#******************************************************************************

# Retrieve metadata from SMAP files.
# Note: the last file is used for 
# non-file specific metadata.
# ==================================

  my ($fileName, $creationDate, $version, $doi);

  getSMAPInfo(undef,$config);

  foreach my $pathname (@$files) {

    getSMAPInfo($pathname,$config);

    my $name      = basename $pathname;
    $fileName     = append([$fileName, $name]);
    $creationDate = append([$creationDate, $config->{SMAP_creationDate}]);
    $version      = append([$version, $config->{SMAP_CompositeReleaseID}]);
    $doi          = append([$doi, $config->{SMAP_identifier_product_DOI}]);

  }

  GENERIC_SMAP_NAMESPACE:

  $config->{SMAP_FILE}         = $files->[-1];
  $config->{SMAP_fileName}     = $fileName;
  $config->{SMAP_creationDate} = $creationDate;
  $config->{SMAP_version}      = $version;
  $config->{SMAP_DOI}          = $doi;

  $config->{SMAP_LAST_FILE}    = $files->[-1] // $config->{SMAP_LAST_FILE};

  SMAP_ID_NAMESPACE:

  $config->{$id . "_FILE"}         = $files->[-1];
  $config->{$id . "_fileName"}     = $fileName;
  $config->{$id . "_creationDate"} = $creationDate;
  $config->{$id . "_version"}      = $version;
  $config->{$id . "_DOI"}          = $doi;

  $config->{$id . "_CompositeReleaseID"} = $config->{SMAP_CompositeReleaseID};

  my $tmp = $id . "_FILE";

}

#******************************************************************************
sub getSMAPInfo { SMAP_FILE: my $file = shift;
                  CONFIG:    my $config = shift;
#******************************************************************************
# English Name: Get SMAP Information
# -------------
#
# Purpose: Extracts pertinent metadata information from the specified SMAP
# -------- file by querying the ISO 19115 metadata group information contained
#          on the file.
#
# Language: Perl
# ---------
#
# Usage: $rc = getSMAPInfo($file,$config);
# ------ $rc = -1 if $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $file                 string       IN  name of SMAP file containing the ISO
#                                        19115 metadata groups.
#
# $config               CONFIG    INOUT  CONFIG referent to receive the
#                                        metadata. Existing content will be
#                                        replaced where the namespace overlaps.
#
# $rc                  integer      OUT  function return value (see usage):
#
#                                        1: success
#                                       -1: Exception occurred
#
# $eh            ERROR_HANDLER      ---  ERROR::Handler referent.
#
#                                        Thrown Exceptions: none
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/24/2014      J.Ardizzone  created.
#******************************************************************************

  METADATA: my %meta;
  METADATA: my $meta = METADATA->new();

# Retrieve metadata information from
# the specified SMAP file.
# ==================================

  DATASET_IDENTIFICATION:

  %meta = $meta->h5dump("-g Metadata/DatasetIdentification " . $file);
  $config->{SMAP_CompositeReleaseID} = $meta{CompositeReleaseID};
  $config->{SMAP_creationDate} = $meta{creationDate};

  SERIES_IDENTIFICATION:

  %meta = $meta->h5dump("-g Metadata/SeriesIdentification " . $file);
  $config->{SMAP_identifier_product_DOI} = $meta{identifier_product_DOI};

# Get SMAP Documentation Information
# ==================================

  getSMAPDocInfo($file,$config);

}

sub getSMAPDocInfo { STRING: my $file = shift;
                     CONFIG: my $config = shift;

  METADATA: my %meta;
  METADATA: my $meta = METADATA->new();

  PLATFORM_DOCUMENT:

  %meta = $meta->h5dump("-g Metadata/AcquisitionInformation/platformDocument " . $file);

  $config->{SMAP_platformDocument_publicationDate} = $meta{publicationDate};
  $config->{SMAP_platformDocument_edition} = $meta{edition};
  $config->{SMAP_platformDocument_title} = $meta{title};

  RADAR_DOCUMENT:

  %meta = $meta->h5dump("-g Metadata/AcquisitionInformation/radarDocument " . $file);

  $config->{SMAP_radarDocument_publicationDate} = $meta{publicationDate};
  $config->{SMAP_radarDocument_edition} = $meta{edition};
  $config->{SMAP_radarDocument_title} = $meta{title};

  RADIOMETER_DOCUMENT:

  %meta = $meta->h5dump("-g Metadata/AcquisitionInformation/radiometerDocument " . $file);

  $config->{SMAP_radiometerDocument_publicationDate} = $meta{publicationDate};
  $config->{SMAP_radiometerDocument_edition} = $meta{edition};
  $config->{SMAP_radiometerDocument_title} = $meta{title};

}

#******************************************************************************
sub getCRIDInfo { CLOCK:  my $time = shift;
                  DMGR:   my $output = shift;
                  CONFIG: my $config = shift;
#******************************************************************************

  my %old = fgetCRIDInfo($time, $output, $config);
  my %new = cgetCRIDInfo($config);

  %old = %new if ! %old;

  foreach my $key (keys %new) { $new{$key} = $old{$key} if $new{$key} eq undef }

  my $meta = METADATA->new();
  my %changeLog = $meta->update(\%old,\%new);

  @{$config}{keys %new} = values %new;
  $config->{changeLog} = \%changeLog;

}

sub cgetCRIDInfo { CONFIG: $config = shift;

  my $root = $config->{L4_SM_ROOT};
  my $collection_id = $config->{COLLECTION_ID};

# Retrieve the current/new
# state of the CRID parameters.
# =============================

  my %crid;
  my @keys;
  my ($path, $pathname);
  my $meta = METADATA->new();

  $path = File::Spec->catdir($root, "crid", $collection_id);
  CONFIG: my $cfg = CONFIG->new($path,%$config);

  $pathname = File::Spec->catfile($root, "crid", "config");
  @keys = $cfg->keys($pathname);

  $pathname = File::Spec->catfile($root, "crid", $collection_id, "config");
  push @keys, $cfg->keys($pathname);

  @crid{@keys} = @{$cfg}{@keys};
  %crid = $meta->execute(%crid);

  return %crid;
}

sub fgetCRIDInfo { CLOCK:  my $time = shift;
                   DMGR:   my $output = shift;
                   CONFIG: my $config = shift;

  CLOCK:     my %times;
  FILENAMES: my %files;

  ($times{GPH}, $files{GPH}) = findLastFile($time,$output->{GPH},$config);
  ($times{AUP}, $files{AUP}) = findLastFile($time,$output->{AUP},$config);
  ($times{LMC}, $files{LMC}) = findLastFile($time,$output->{LMC},$config);

  print "Last GPH File: $files{GPH}\n";
  print "Last AUP File: $files{AUP}\n";
  print "Last LMC File: $files{LMC}\n";

  COLLECTION: my $id = $config->{COLLECTION_ID};
  COLLECTION: my $maxkey;

  foreach my $key (keys %times) {

    $times{$key} or next;
    $maxkey = $maxkey // $key;

    $times{$key} > $times{$maxkey} and do {$maxkey = $key};

  }

  $maxkey or return ();

  $config->{SPL4SM_FILE}   = $files{$maxkey};
  print "Last File: $files{$maxkey}\n";

  METADATA: my (%meta, %crid);
  METADATA: my $meta = METADATA->new();

  %meta = $meta->h5dump("-g Metadata/CRID/Root " . $files{$maxkey});
  @crid{keys %meta} = values %meta;

  %meta = $meta->h5dump("-g Metadata/CRID/$id " . $files{$id});
  @crid{keys %meta} = values %meta;

  return %crid;

}
  
#******************************************************************************
sub findLastFile { CLOCK:  my $time = shift;
                   DTR:    my $dtr = shift;
                   CONFIG: my $config = shift;
#******************************************************************************
# English Name: Find Last File
# -------------
#
# Purpose: Looks for the most recent file for the granule type described by
# -------- the input data transaction.
#
# Language: Perl
# ---------
#
# Notes: 1. The purpose of this method is to find the file with the latest
# ------    composite release ID (CRID). This file will be the last file
#           produced in the simplest scenario. However, the logic becomes
#           slightly more complicated when there are multiple processing 
#           instances for the same date/time (i.e. there are files with a
#           product counter greater than one). In this case, the CRID will
#           start with the value assigned to the file with the largest
#           product counter matching the first data day/time seached using this
#           method. Subsequent searches will then yield the last file created.
#
# See Also: CLOCK.pm, DTR.pm, CONFIG.pm, METADATA.pm
# ---------
#
# Prerequisites:
# --------------
#
# Usage: ($t_create, $file) = findLastFile($time, $dtr, $config);
# ------ @result = findLastFile($time, $dtr, $config);
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK object defining the current data
#                                        day and time. 
#
# $dtr                     DTR       IN  DTR object describing the file 
#                                        attributes to be searched. 
#
# $config               CONFIG       IN  CONFIG object describing all runtime
#                                        configuration parameters.
#
# $t_create              CLOCK      OUT  Creation time of the most recent file
#                                        described by the input data transaction
#                                        object (see note-1). 
#
# $file                 string      OUT  Filename of the most recent file.
#
# @result                ARRAY      OUT  Array containing the returned values.
#                                        A value of null is returned if no
#                                        file is located.
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           01/30/2015      J.Ardizzone  Documented
#******************************************************************************

  my $meta = METADATA->new();

  my ($template) = $dtr->files({FILE_TYPE=>"SCIENCE"});
  $template      =~ s/_\d{3}\.h5/_\*\.h5/;

# Locate the last file. A metadata search for the
# CRID is used as a mechanism for verifying that
# the HDF-5 file is valid.
# ================================================

  for (my $t=$time-1800; $t>=$time-86400; $t-=1800) {

    my $files  = $config->time_interp($template,$t);
    my ($file) = reverse sort < $files >;
    my %meta   = $meta->h5dump("-g Metadata/DatasetIdentification " . $file);

    -s $file or next;
    $meta{CompositeReleaseID} or next;

    my $ctime = (stat($file))[10];
    my $t_create = gmtime($ctime);
    return ($t_create, $file);

  }

  return ();

}

#******************************************************************************
sub getRunTimeConfig
#******************************************************************************
# English Name: Get Run-Time Configuration
# -------------
#
# Purpose: 
# --------
#
# Language: Perl
# ---------
#
# Notes:
# ------
#
# Interface:              Type   Access  Description
# ----------                     Intent
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           mm/dd/ccyy      J.Ardizzone  created.
#******************************************************************************
{

# Retrieve command-line arguments
# ===============================

  my %option = getArgs();

  my $dictionary      = $option{OP_DEFINE};
  $option{DICTIONARY} = $dictionary;

# Set key parameters
# ==================

  $option{NAME}  = "SMAP_L4_OPS";
  $option{CLASS} = "L4_SM_genISO";

  $option{DATE} = $option{OP_DATE};
  $option{TIME} = 0;

  $option{L4_SM_ROOT}    = $option{OP_STREAM_DIR};

  $option{L4_SM_PATH}    = File::Spec->catdir($option{L4_SM_ROOT}, "bin");
  $option{L4_SM_GEN_ISO} = File::Spec->catdir($option{L4_SM_ROOT}, "genISO");
  $option{L4_SM_IMPORT}  = File::Spec->catdir($option{L4_SM_ROOT}, "import");
  $option{L4_SM_MODEL}   = File::Spec->catdir($option{L4_SM_ROOT}, "runModel");
  $option{L4_SM_INPUT}   = File::Spec->catdir($option{L4_SM_MODEL}, "output",
                                                                    "ldas");
  $option{L4_SM_OUTPUT}  = File::Spec->catdir($option{L4_SM_GEN_ISO},"output");
  $option{L4_SM_RUN}     = File::Spec->catdir($option{L4_SM_GEN_ISO}, "run");
  $option{L4_SM_RIP}     = File::Spec->catdir($option{L4_SM_GEN_ISO}, "rip");

  $option{PRODUCT_COUNTER} = substr($option{OP_PRODUCT_COUNTER}+1000, 1);

  my $log_file           = File::Spec->catdir($option{L4_SM_ROOT}, "log");
  $ENV{L4_LOG_FILE}      = $ENV{L4_LOG_FILE} // $log_file;
  $option{L4_LOG_FILE}   = $ENV{L4_LOG_FILE};

  $ENV{PATH} = join ":", $option{L4_SM_PATH}, $ENV{PATH};

  my $lh = LOG::Handler->new(SYSTEM=>"L4_SM_SPS",
                             APPLICATION=>"L4_SM_genISO",
                             DATE=>$option{DATE},
                             TIME=>$option{TIME});

# Return the run-time configuration
# =================================

  my $config = CONFIG->new($option{L4_SM_GEN_ISO},%option);

  return $config;
}

#******************************************************************************
sub getArgs
#******************************************************************************
# English Name: Get Arguments
# -------------
#
# Purpose: Retrieves command-line arguments and options. 
# --------
#
# Language: Perl
# ---------
#
# Notes: 1. The environment variable, SMAP_OPS_DIR, must be defined if the
# ------    stream to be processed is identified by its type and name only
#           (i.e. the full pathname is not specified as a command-line
#           argument).
#
# See Also: getRunTimeConfig()
# ---------
#
# Prerequisites: $ENV{SMAP_OPS_DIR}
# --------------
#
# Usage: %options = getArgs()
# ------ $rc = $eh->isError()
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# %options                HASH      OUT  Hash table of returned command-line
#                                        options.
#
#  {OP_FORCE}          boolean      OUT  Forces processing to continue even
#                                        if some secondard inputs are
#                                        incomplete or unavailable.
#  
#  {OP_PROD_COUNTER}   integer      OUT  Product counter expressed as a 3-digit
#                                        integer (default: 001).
#
#  {OP_RUN_FREQ}       integer      OUT  Run frequency in seconds. This is the
#                                        interval of time between invocation
#                                        of this application (default: 3600).
#
#  {OP_STREAM_NAME}     string      OUT  Name of the stream to be processed
#                                        (e.g. SPL4SM_V05005).
#  
#  {OP_STREAM_TYPE}     string      OUT  Name of the stream type to be
#                                        processed (e.g. SPL4SM).
#
#  {OP_RESUME}         boolean      OUT  Resume post-model processing. This
#                                        option is useful when errors
#                                        occur in post-processing and cause
#                                        a premature exit.
#
#  {STREAM_DIR}         string      OUT  Pathname of the stream directory. This
#                                        can be specified on the command-line
#                                        or can be derived from the stream
#                                        type and name options in combination
#                                        with the environment variable:
#
#                                        SMAP_OPS_DIR
#
# $eh           ERROR::Handler      OUT  Error handler object.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Unable to identify stream directory
#                                        2: Stream directory does not exist
#                                        3: Help on usage requested
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           11/03/2014      J.Ardizzone  created.
#******************************************************************************
{

  my %options = ();
  my %define  = ();
  my ($crid, $date, $export, $force, $help, $idle, $man, $noHDF, $noPost, $pc);
  my ($resume, $run_freq, $stream_name, $stream_type);


# Retrieve command-line options
# =============================

  GetOptions ("help|h" => \$help,
              "man" => \$man,
              "crid" => \$crid,
              "date=i" => \$date,
              "define=s" => \%define,
              "export" => \$export,
              "force|f" => \$force,
              "idle=i" => \$idle,
              "noHDF" => \$noHDF,
              "noPost" => \$noPost,
              "pc=i" => \$pc,
              "resume" => \$resume,
              "run_freq|rf=i" => \$run_freq,
              "stream_name|sn=s" => \$stream_name,
              "stream_type|st=s" => \$stream_type) or pod2usage(2);

  my @path = File::Spec->splitdir( $ARGV[0] );

  $options{OP_FORCE}           = $force;
  $options{OP_DEFINE}          = \%define;
  $options{OP_PRODUCT_COUNTER} = $pc // 1;
  $options{OP_DATE}            = $date // $ARGV[1];
  $options{OP_CRID}            = $crid;

  $options{OP_STREAM_NAME}  = $stream_name // pop @path;
  $options{OP_STREAM_TYPE}  = $stream_type // pop @path;
  $options{OP_STREAM_DIR}   = $ARGV[0] // File::Spec->catdir($ENV{SMAP_OPS_DIR},
                                          $options{OP_STREAM_TYPE},
                                          $options{OP_STREAM_NAME});

  $help and pod2usage(1);
  $man  and pod2usage(-verbose => 2);

  -d $options{OP_STREAM_DIR} or do {
    print "The stream directory does not exist. Please check arguments.\n";
    exit 1;
  };

  return %options;

}

sub getTileCoordFile
{

# Argument List
# -------------

  CONFIG: my $config = shift;

# Local Variables
# ---------------

  STRING:  my $this = "getTileCoordFile";

  STRING:  my (@file, @files);
  DMGR:    my $input = DMGR->new($config->{L4_SM_INPUT},%$config);

  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  $eh->comment("Retrieving tile coordinate information");

  ($input->stat("TILE"))[0] or 
    return $eh->fatal(1,TYPE=>"TILE");

  @files = $input->files("TILE");
  @file = grep /tilecoord\.bin/, @files;

  @file or return $eh->error(1,TYPE=>"TILE");

  $ENV{LDAS_TILE_COORD_FILE} = shift @file;

  return $ENV{LDAS_TILE_COORD_FILE};

}

#******************************************************************************
sub genHDF { CLOCK:  my $time = shift;
             DMGR:   my $input = shift;
             DMGR:   my $output = shift;
             CONFIG: my $config = shift;
#******************************************************************************
# English Name: Generate HDF-5 Files
# -------------
#
# Purpose: Converts the LDAS binary files to HDF-5.
# --------
#
# Language: Perl
# ---------
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, ERROR::Handler.pm, &error_handler
# ---------
#
# Usage: $rc = genHDF($time, $input, $output, $config)
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the current
#                                        date/time.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing the
#                                        system configuration and state. The
#                                        granule type to be written to HDF is
#                                        stored in the hash under COLLECTION_ID.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Error creating output directory
#                                        2: Error converting data to HDF-5
#                                        3: Unknown collection type. See
#                                           $config->{COLLECTION_ID}.
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           04/11/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "genHDF";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Retrieve the input and output filenames.
# ========================================

  my $type    = $config->{COLLECTION_ID};
  my $in_dtr  = $input->{$type};
  my $out_dtr = $output->{$type};

  my $datetime = $time->datetime;
  $eh->comment("Generating the HDF-5 file: " .
                      "Collection = $type, " .
                      "Time = $datetime");

  $in_dtr  or return $eh->fatal(3,TYPE=>$type);
  $out_dtr or return $eh->fatal(3,TYPE=>$type);

  LDAS_FILE_TMPLT: my ($in_file)  = $in_dtr->files();
  HDF_FILE_TMPLT:  my ($out_file) = $out_dtr->files();
  META_FILE:       my $meta_file  = File::Spec->catfile($config->{L4_SM_RUN},
                                                  $type . "_local_meta.nml");

# Time interpolate the output path
# in order to create the directory.
# =================================

  my $pathname = $time->strftime($out_file);
  my $path     = dirname $pathname;

  if ( ! -d $path) { mkpath($path) or return $eh->fatal(1,PATH=>$path) }

# Convert the LDAS data to HDF-5.
# ===============================

  my $date = $time->strftime("%Y%m%d");
  my $time = $time->strftime("%H%M%S");
  my ($inc_sec) = ($in_dtr->times())[2];

  system "ldas2daac.x $date $time $date $time $inc_sec " .
            "$meta_file $in_file $out_file" and return $eh->error(2);

  return 1;
}

#******************************************************************************
sub genQA  { CLOCK:  my $time = shift;
             DMGR:   my $input = shift;
             DMGR:   my $output = shift;
             CONFIG: my $config = shift;
#******************************************************************************
# English Name: Generate Quality Assurance Files
# -------------
#
# Purpose: Creates Quality Assurance (QA) files from HDF-5 granules.
# --------
#
# Language: Perl
# ---------
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, ERROR::Handler.pm, &error_handler
# ---------
#
# Usage: $rc = genQA($time, $input, $output, $config)
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the current
#                                        date/time.
#
# $input                  DMGR       IN  DMGR referent describing all input
#                                        data generated by the LDAS.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG    INOUT  CONFIG class hash referent describing
#                                        the system configuration and state. 
#                                        QA metadata elements are returned:
#
#  {COLLECTION_ID}                    IN  Three character collection identifier.
#
#  {QA_FILE}                         OUT  pathname of created QA file.
#
#  {SPL4SM_QAFileName}               OUT  name of created QA file.
#
#  {SPL4SM_QACreationDate}           OUT  creation time of the QA file:
#
#                                         e.g. 2000-02-29T12:34:56.0000Z
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Missing data transaction
#                                        2: Missing input data
#                                        3: Error generating QA file
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           05/02/2014      J.Ardizzone  created.
#           07/16/2014      J.Ardizzone  modified command-line arguments for
#                                        gen_qa.py (--landfrac not needed) with
#                                        revision 1.2.2.1 .
#******************************************************************************

  FUNCTION_NAME: my $this = "genQA";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Retrieve the input and output filenames.
# ========================================

  my $type    = $config->{COLLECTION_ID};
  my $out_dtr = $output->{$type};
  my $lmc_dtr = $output->{LMC};

  my $datetime = $time->datetime;
  $eh->comment("Generating the QA file: " .
                      "Collection = $type, " .
                      "Time = $datetime");

  $out_dtr or return $eh->fatal(1,TYPE=>$type);
  $lmc_dtr or return $eh->fatal(1,TYPE=>"LMC");

# Retrieve the HDF and QA filenames
# for the current collection.
# =================================

  my ($file, @files);

  @files = $out_dtr->files();

  $file  = (grep /\.h5$/, @files)[0];
  my $hdf_file = $time->strftime($file);

  $file  = (grep /\.qa$/, @files)[0];
  my $qa_file = $time->strftime($file);

# Retrieve the LMC filename
# =========================

  @files = $lmc_dtr->files();

  $file  = (grep /\.h5$/, @files)[0];
  my $lmc_file = $time->strftime($file);

  $file  = (grep /\.qa$/, @files)[0];
  my $lmc_qa  = $time->strftime($file);

# Generate the QA file
# ====================

  -f $lmc_file or return $eh->error(2,FILE=>$lmc_file);
  -f $hdf_file or return $eh->error(2,FILE=>$hdf_file);

  my $option = $type . "file";
  $option =~ tr/A-Z/a-z/;

  unlink $qa_file if -f $qa_file;

  system "gen_qa.py $lmc_file " .
         "--$option $hdf_file" and return $eh->error(3,TYPE=>$type);

# Save file information and
# return.
# =========================

  FILE_CREATION: my $ctime = (stat($qa_file))[10];
  CLOCK:         my $t = gmtime($ctime);

  $config->{QA_FILE} = $qa_file;
  $config->{SPL4SM_QAFileName} = basename $qa_file;
  $config->{SPL4SM_QACreationDate} = $t->datetime . ".000Z";

  return 1;
}

#******************************************************************************
sub compressHDF { CLOCK:  my $time = shift;
                  DMGR:   my $output = shift;
                  CONFIG: my $config = shift;
#******************************************************************************
# English Name: Compress HDF-5 Files
# -------------
#
# Purpose: Compresses HDF-5 files using the HDF-5 toolkit (h5repack).
# --------
#
# Language: Perl
# ---------
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, ERROR::Handler.pm, &error_handler
# ---------
#
# Usage: $rc = compressHDF($time, $output, $config)
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the current
#                                        date/time.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing the
#                                        system configuration and state. The
#                                        granule type to be compressed is
#                                        stored in the hash under COLLECTION_ID.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: HDF file not found
#                                        2: Error returned from h5repack
#                                        3: Unknown collection type. See
#                                           $config->{COLLECTION_ID}.
#                                        4: Error returned from h5format_convert
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           04/11/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "compressHDF";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Retrieve the HDF filename.
# ==========================

  my $type = $config->{COLLECTION_ID};
  my $dtr  = $output->{$type};

  my $datetime = $time->datetime;
  $eh->comment("Compressing the HDF5 file: " .
                      "Collection = $type, " .
                      "Time = $datetime");

  $dtr or return $eh->error(3,TYPE=>$type);

  HDF_FILE:  my ($hdf_file) = $dtr->files();
  $hdf_file = $time->strftime($hdf_file);

  -f $hdf_file or return $eh->error(1,FILE=>$hdf_file);

# Compress the HDF-5 file.
# ========================

  system "h5repack -v -L -f GZIP=3 $hdf_file $hdf_file" . ".tmp"
                             and return $eh->error(2);

  move ($hdf_file . ".tmp", $hdf_file);

  system "h5format_convert $hdf_file" and return $eh->error(4);

  return 1;
}

#******************************************************************************
sub insertGroupMeta { CLOCK:  my $time = shift;
                      DMGR:   my $output = shift;
                      CONFIG: my $config = shift;
#******************************************************************************
# English Name: Insert Group Metadata
# -------------
#
# Purpose: Inserts ISO group-level metadata into HDF-5 granules.
# -------- 
#
# Language: Perl
# ---------
#
# Usage: $rc = insertGroupMeta($time, $output, $config);
# ------ $exception = $eh->isError();
#
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the date/time
#                                        of the granule to receive metadata
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG    INOUT  CONFIG referent containing all
#                                        metadata information for populating
#                                        the granule.
#
# $rc                  integer      OUT  function return value (see $exception):
#
#                                        0: failure
#                                        1: success
#
# $exception           integer      OUT  Thrown Exceptions:
#
#                                        0: no exception occurred
#                                        1: missing data transaction
#                                        2: error returned from metadata
#                                           insertion executable
#
# $eh            ERROR_HANDLER      ---  ERROR::Handler referent.
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#           03/29/2014      J.Ardizzone  created.
#******************************************************************************

  STRING:        my $this = "insertGroupMeta";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Retrieve HDF-5 filename.
# ========================

  STRING: my $type = $config->{COLLECTION_ID};
  DTR:    my $dtr  = $output->{$type};

  my $datetime = $time->datetime;
  $eh->comment("Inserting the HDF5 group metadata: " .
                      "Collection = $type, " .
                      "Time = $datetime");

  $dtr or return $eh->error(1,TYPE=>$type);

  FILETMPLT: my $file;
  FILETMPLT: my @files = $dtr->files();

  $file  = (grep /\.h5$/, @files)[0];
  FILENAME:  my $HDF_file = $time->strftime($file);
  $config->{SPL4SM_fileName} = basename $HDF_file;

  $file  = (grep /\.qa$/, @files)[0];
  FILENAME:  my $QA_file = $time->strftime($file);
  $config->{SPL4SM_QAFileName} = basename $QA_file;

# Define a UUID
# =============

  my $ug = new Data::UUID;
  $config->{UUID} = $ug->create_str();

# Define and populate the namelist with
# metadata.
# =====================================

  FILENAME: my $namelist = $type . "_group_meta.nml";
  FILENAME: my $group_meta = File::Spec->catdir($config->{L4_SM_RUN},$namelist);

  $config->jobConfig($config->{L4_SM_RIP},$config->{L4_SM_RUN},TIMELESS=>1);

# Insert the metadata into the granule.
# =====================================

  system "insertMetaGroups.x $group_meta $HDF_file"
                             and return $eh->error(2);

  return 1;

}

sub insertConfig { CLOCK:  my $time = shift;
                   DMGR:   my $output = shift;
                   CONFIG: my $config = shift;

  STRING:        my $this = "insertConfig";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

  COLLECTION: my $type = $config->{COLLECTION_ID};
  DTR:        my $dtr  = $output->{$type};

  $dtr or return $eh->error(1,TYPE=>$type);

  FILETMPLT: my @files = $dtr->files();
  FILETMPLT: my $file  = (grep /\.h5$/, @files)[0];
  FILENAME:  my $HDF_file = $time->strftime($file);

# Write out the configuration
# parameters to the HDF-5 file.
# =============================

  FILENAME:  my $pathname;
  METADATA:  my (@keys, %meta); 
  METADATA:  my $meta = METADATA->new();
  DIRECTORY: my $root = $config->{L4_SM_ROOT};

  $pathname = File::Spec->catfile($root, "config");
  @keys = $config->keys($pathname); 
  %meta = $config->hash(@keys);
  $meta->addGroup("Metadata/Config",%meta);

  $pathname = File::Spec->catfile($root, "crid", "config");
  @keys = $config->keys($pathname); 
  %meta = $config->hash(@keys);
  $meta->addGroup("Metadata/CRID/Root",%meta);

  $pathname = File::Spec->catfile($root, "crid", $type, "config");
  @keys = $config->keys($pathname); 
  %meta = $config->hash(@keys);
  $meta->addGroup("Metadata/CRID/" . $type, %meta);

  HASH_REF: my $changeLog = $config->{changeLog} // {};
  $meta->addGroup("Metadata/CRID/changeLog", %$changeLog);

  $meta->write($HDF_file);

# insertConfigTar($HDF_file,$config);

  return 1;
}
#******************************************************************************
sub insertXMLMeta { CLOCK:  my $time = shift;
                    DMGR:   my $output = shift;
                    CONFIG: my $config = shift;
#******************************************************************************
# English Name: Insert XML Metadata
# -------------
#
# Purpose: Creates ISO 19139 XML data by transforming the group metadata on the
# -------- HDF file using an XSL Transform. The XML is created as an autonomous
#          file and also inserted into the HDF file as a string attribute.
#
# Language: Perl
# ---------
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, ERROR::Handler.pm, &error_handler
# ---------
#
# Usage: $rc = insertXMLMeta($time, $output, $config)
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the current
#                                        date/time.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing the
#                                        system configuration and state. The
#                                        granule type to be compressed is
#                                        stored in the hash under COLLECTION_ID.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Input file is missing
#                                        2: Missing data transaction
#                                        3: Non-zero return code from h5dump
#                                        4: Non-zero return code from saxon
#                                        5: Non-zero return code from XML
#                                           insertion executable
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           04/11/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "insertXMLMeta";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Retrieve the HDF filename.
# ==========================

  my $type = $config->{COLLECTION_ID};
  my $dtr  = $output->{$type};
  my $transform = File::Spec->catfile($config->{L4_SM_RUN},"hdf5xml_to_isoxml.xsl");
  my $saxon = File::Spec->catfile($config->{L4_SM_PATH},"saxon9he.jar");

  my $datetime = $time->datetime;
  $eh->comment("Inserting the ISO dataset XML metadata: " .
                      "Collection = $type, " .
                      "Time = $datetime");

  $dtr or return $eh->error(2,TYPE=>$type);

# Identify the HDF and XML filenames
# ==================================

  my @files = $dtr->files();
  my ($hdf_file) = grep /\.h5$/, @files;
  my ($iso_xml_file) = grep /\.xml$/, @files;

  $hdf_file = $time->strftime($hdf_file);
  $iso_xml_file = $time->strftime($iso_xml_file);

  my $xml_tmp_file = $hdf_file;
  $xml_tmp_file =~ s/\.h5/\.xml/;

  -f $hdf_file or return $eh->error(1,FILE=>$hdf_file);

# Create runtime input files
# ==========================

  $config->jobConfig($config->{L4_SM_RIP},$config->{L4_SM_RUN},TIMELESS=>1);

# Extract the group-level metadata from
# the HDF-5 file.
# =====================================
  
  my $output = `h5dump --xml --onlyattr -m "%12.7g" $hdf_file`;
  return $eh->error(3) if $?;

  open (my $fh, ">$xml_tmp_file");
  print $fh $output;
  close $fh;

# Create the ISO 19139 XML file
# =============================

  system "java -cp $saxon net.sf.saxon.Transform -tree:linked -t -T " .
         "-s:$xml_tmp_file -xsl:$transform -o:$iso_xml_file"
         and return $eh->error(4);

# Insert the ISO XML file into the
# HDF-5 file as a string attribute.
# =================================

  my $filesize = -s $iso_xml_file;
  my $attribute_name = "/Metadata/iso_19139_dataset_xml"; 
  system "insertXMLFile.x $attribute_name $iso_xml_file $hdf_file $filesize"
                                         and return $eh->error(5);

# Clean Up
# ========

  unlink $xml_tmp_file;

  return 1;
}

#******************************************************************************
sub insertSeriesXML { CLOCK:  my $time = shift;
                      DMGR:   my $output = shift;
                      CONFIG: my $config = shift;
#******************************************************************************
# English Name: Insert Series XML Metadata
# -------------
#
# Purpose: Inserts the curated ISO 19139 Series XML data into the HDF5
# -------- granules.
#
# Language: Perl
# ---------
#
# See Also: CLOCK.pm, DMGR.pm, CONFIG.pm, ERROR::Handler.pm, &error_handler
# ---------
#
# Usage: $rc = insertSeriesXML($time, $output, $config)
# ------ $exception = $eh->isError();
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $time                  CLOCK       IN  CLOCK referent set to the current
#                                        date/time.
#
# $output                 DMGR       IN  DMGR referent describing all output
#                                        collection granules.
#
# $config               CONFIG       IN  CONFIG referent describing the
#                                        system configuration and state. The
#                                        granule type to be compressed is
#                                        stored in the hash under COLLECTION_ID.
#
# $rc                  integer      OUT  function return value:
#
#                                        0: invalid or incorrect usage
#                                        1: success
#
#                                        undef: exception occurred.
#
# $eh           ERROR::Handler      OUT  Error handler referent.
#
# $exception           integer      OUT  Thrown Exception:
#
#                                        1: Missing data transaction file
#                                        2: HDF file not found
#                                        3: Series XML file is missing or empty
#                                        4: Error occurred during XML insertion
#    
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------   
#           06/12/2014      J.Ardizzone  created.
#******************************************************************************

  FUNCTION_NAME: my $this = "insertSeriesXML";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Retrieve the HDF filename.
# ==========================

  my $type = $config->{COLLECTION_ID};
  my $lc_type = lc $type;

  my $datetime = $time->datetime;
  $eh->comment("Inserting the ISO series XML metadata: " .
                      "Collection = $type, " .
                      "Time = $datetime");

  my $dtr  = $output->{$type};
  $dtr or return $eh->error(1,TYPE=>$type);

# Identify the HDF and XML filenames
# ==================================

  my ($hdf_file) = $dtr->files({FILE_TYPE=>"SCIENCE"});
  $hdf_file = $time->strftime($hdf_file);

  -f $hdf_file or return $eh->error(2,FILE=>$hdf_file);

# Static pre-generated XML series file.
# my $name = $type . "_series.xml";
# my $series_xml_file = File::Spec->catfile($config->{L4_SM_RUN},$name);

# Dynamically generated XML series file.
  my $path = dirname $hdf_file;
  my $series_xml_file = File::Spec->catfile($path, "L4_SM_" . $lc_type .
                                                      "_series.xml");

# Create runtime input files
# ==========================

  $config->jobConfig($config->{L4_SM_RIP},$config->{L4_SM_RUN},TIMELESS=>1);

# Insert the ISO XML file into the
# HDF-5 file as a string attribute.
# =================================

  my $filesize = -s $series_xml_file;
  $filesize or return $eh->error(3,FILE=>$series_xml_file);

  my $attribute_name = "/Metadata/iso_19139_series_xml"; 
  system "insertXMLFile.x $attribute_name $series_xml_file $hdf_file $filesize"
                                         and return $eh->error(4);

  return 1;
}

#******************************************************************************
sub insertConfigTar { STRING: my $fname = shift;
                      CONFIG: my $config = shift;
#******************************************************************************

  STRING:        my $this = "insertConfigTar";
  ERROR_HANDLER: my $eh = ERROR::Handler->new(\&error_handler,$this);

# Get a listing of the run-time
# files for the data stream.
# =============================

  chdir "$config->{L4_OPS_directoryID}";
  chdir "SPL4SM";

  my @files = ();
  my $tar_file = $fname . ".tar";
  my $find = FIND->new($config->{L4_SM_STREAM_version});

  push @files, $find->files('config$');
  push @files, $find->files('\.nml$');
  push @files, $find->files('\.dtr$');
  push @files, $find->files('\.j$');
  push @files, $find->files('\.rip$');
  push @files, $find->files('clock$');
  push @files, $find->files('log$');
# push @files, $find->files('\.status$');
# push @files, $find->files('g5_modules$');
# push @files, $find->files('\.x$');

# Insert the run-time configuration
# tarball into the HDF-5 file.
# =================================

  system "tar cvf $tar_file @files";

  FILESIZE: my $size = -s $tar_file;

# system "h5import $tar_file -d $size -p Config/runTimeConfigTar" .
#        " -t UIN -s 8 -o $fname" and die "h5import failed";

  unlink $tar_file;

  return 1;
}

#******************************************************************************
sub append { my $array = shift;
             my %options = scalar(@_) ? @_ : ();
#******************************************************************************

  my @array = @$array;
# my $delimiter = $options{DELIMITER} // '|';
  my $delimiter = $options{DELIMITER} // "','";
  my $default = $options{DEFAULT} // "missing";

  shift @array if ! defined $array[0];
  @array or return undef;

  @array = map { defined $_ ? $_ : $default } @array;
  return join $delimiter, @array;

}

sub basenames { my $files = shift;

  my @files = map { basename $_ } @$files;
  return \@files;
}

#******************************************************************************
sub error_handler { my $error_handle = shift;
                    my $error_code   = shift;
                    my %options      = scalar(@_) ? @_ : ();
#******************************************************************************
# English Name: Error Handler
# -------------
#
# Purpose: Reports exceptions for the invoking method. This error handler
# -------- is a catalog of registed exceptions for all methods contained in this
#          application.
#
# Language: Perl
# ---------
#
# See Also: ERROR::Handler.pm, LOG::Handler.pm
# ---------
#
# Notes: 1. Developers must register new or changed exceptions by adding or
# ------    updating the error handler blocks contained in this method.
#
#        2. This method is intended to be invoked by the ERROR::Handler
#           module. Please see ERROR::Handler.pm for more information.
#
# Usage: $eh = ERROR::Handler->new(\&error_handler,$error_handle);
# ------ $eh->$type($error_code, %options);
#
# Interface:              Type   Access  Description
# ----------                     Intent
#
# $eh           ERROR::Handler       IN  Error Handler object instantiated by
#                                        the invoking method.
#
# \&error_handler         CODE       IN  Reference to this method.
#
# $type                 string       IN  error method type (see note-2):
#
#                                        comment, advisory, warning, error,
#                                        fatal
#
# $error_handle         string       IN  name of invoking method.
#
# $error_code          integer       IN  exception identifier.
#
# %options                hash       IN  optional arguments used to resolve
#                                        an exception message.
#
# Programmer: Joseph V. Ardizzone
# ----------- (NASA Goddard Space Flight Center)
#             (Global Modeling and Assimilation Office - GMAO)
#
# Modified:       Date           Author  Description
# ---------
#             2/4/2015      J.Ardizzone  Prolog added.
#******************************************************************************

  my $type = $options{ERROR_TYPE};
  my $lh   = LOG::Handler->new(HANDLE=>$error_handle);

# Trap Error Handler Events
# =========================

  defined $options{ERROR_ELAPSED_TIME} and do {

    my $seconds = $options{ERROR_ELAPSED_TIME};
    $lh->comment(0,"Exiting $error_handle : [${seconds}s]");
    return;

  };

  $options{ERROR_TRACEBACK} and do {

    $lh->error($error_code,"Traceback: $error_handle() encountered an error.");
    return;

  };

# Issue a comment when the
# error code is zero.
# ========================

  $error_code or return $lh->comment(0,$options{COMMENT});

# genDAAC() error handle
# ======================

  $error_handle eq "genDAAC" and do {

    $error_code == 1 and do {

      $lh->$type(1,"Missing input data transaction file for " .
                                "collection \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";

  };

# genGPH() error handle
# ======================

  $error_handle eq "genGPH" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing input data transaction file for " .
                   "collection \"$options{TYPE}\"");
    };

    $error_code == 2 and do {
      $lh->$type(2,"Missing output data transaction file for " .
                                "collection \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";

  };

# genAUP() error handle
# ======================

  $error_handle eq "genAUP" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing input data transaction file for " .
                                "collection \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Missing output data transaction file for " .
                                "collection \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";

    return;

  };

# genLMC() error handle
# =====================

  $error_handle eq "genLMC" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing input data transaction file for " .
                                "collection \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Missing output data transaction file for " .
                                "collection \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";

    return;

  };

# getLFOInfo() error handle
# =========================

  $error_handle eq "getLFOInfo" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"LDAS LOG file is missing: \"$options{FILE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;
  };

# getGPHInfo() error handle
# =========================

  $error_handle eq "getGPHInfo" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"LDAS GPH QA file is missing: \"$options{FILE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# getAUPInfo() error handle
# =========================

  $error_handle eq "getAUPInfo" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"LDAS AUP QA file is missing: \"$options{FILE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# getLMCInfo() error handle
# =========================

  $error_handle eq "getLMCInfo" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"LDAS AUP QA file is missing: \"$options{FILE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# getOBSInfo() error handle
# =========================

  $error_handle eq "getOBSInfo" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"LDAS AUP OBSLOG file is missing: \"$options{FILE}\"");
      return;
    };
        
    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# getTileCoordFile() error handle
# ===============================

  $error_handle eq "getTileCoordFile" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Cannot retrieve tile coordinate file for " .
                                "data transaction, " . $options{TYPE});
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# genHDF() error handle
# =====================

  $error_handle eq "genHDF" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Unable to create directory: \"$options{PATH}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Non-zero return code from HDF-5 conversion executable.");
      return;
    };

    $error_code == 3 and do {
      $lh->$type(3,"Unknown collection type: \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# genQA() error handle
# ====================

  $error_handle eq "genQA" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing transaction for type: \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Input file is missing: \"$options{FILE}\"");
      return;
    };

    $error_code == 3 and do {
      $lh->$type(3,"QA generation failed for type: \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# compressHDF() error handle
# ==========================

  $error_handle eq "compressHDF" and do {

    $error_code == 1 and do {
      $lh->$type(1,"HDF file not found: \"$options{FILE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Non-zero return code from h5repack");
      return;
    };

    $error_code == 3 and do {
      $lh->$type(3,"Unknown collection type: \"$options{TYPE}\"");
      return;
    };

    $error_code == 4 and do {
      $lh->$type(4,"Non-zero return code from h5format_convert");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# insertGroupMeta() error handle
# ==============================

  $error_handle eq "insertGroupMeta" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Non-zero return code from HDF-5 " .
                                "metadata insertion executable.");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# insertConfig() error handle
# ==============================

  $error_handle eq "insertConfig" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

# insertXMLMeta() error handle
# ============================

  $error_handle eq "insertXMLMeta" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Input file is missing: \"$options{FILE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 3 and do {
      $lh->$type(3,"Non-zero return code from h5dump ");
      return;
    };

    $error_code == 4 and do {
      $lh->$type(4,"Non-zero return code from saxon transform");
      return;
    };

    $error_code == 5 and do {
      $lh->$type(5,"Non-zero return code from XML insertion executable.");
      return;
    };
    
    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

    };

# insertSeriesXML() error handle
# ==============================

  $error_handle eq "insertSeriesXML" and do {

    $error_code == 1 and do {
      $lh->$type(1,"Missing data transaction for type, \"$options{TYPE}\"");
      return;
    };

    $error_code == 2 and do {
      $lh->$type(2,"HDF-5 file is missing: \"$options{FILE}\"");
      return;
    };

    $error_code == 3 and do {
      $lh->$type(3,"Series XML file is missing or empty: \"$options{FILE}\"");
      return;
    };

    $error_code == 4 and do {
      $lh->$type(4,"Non-zero return code from XML insertion executable.");
      return;
    };

    print STDERR "$error_handle: Unknown error code: $error_code\n";
    return;

  };

    print STDERR "L4_SM_genISO: no error handle for \"$error_handle\"\n";
}
